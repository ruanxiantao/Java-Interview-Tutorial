> 全是干货的技术号：
> 本文已收录在github，欢迎 star/fork：
> https://github.com/Wasabi1234/Java-Interview-Tutorial

# 1 数据结构及算法基础
## 1.1 索引的本质
官方定义：索引（Index）是帮助MySQL高效获取数据的数据结构
本质：索引是数据结构

查询是数据库的最主要功能之一。我们都希望查询速度能尽可能快，因此数据库系统的设计者会从查询算法角度优化

最基本的查询算法当然是[顺序查找](http://en.wikipedia.org/wiki/Linear_search)（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的
好在CS的发展提供了很多更优秀的查找算法，如[二分查找](http://en.wikipedia.org/wiki/Binary_search_algorithm)（binary search）、[二叉树查找](http://en.wikipedia.org/wiki/Binary_search_tree)（binary tree search）等
稍微分析一下会发现，每种查找算法都只能应用于特定数据结构，如二分查找要求被检索数据有序，而二叉树查找只能应用于[二叉查找树](http://en.wikipedia.org/wiki/Binary_search_tree)，但`数据本身的组织结构不可能完全满足各种数据结构`（例如，理论上不可能同时将两列都按顺序进行组织）
所以，在数据之外，数据库系统还维护着`满足特定查找算法的数据结构`，这些数据结构以某种方式引用（指向）数据，这样就可以`在这些数据结构上实现高级查找算法`
这种ADT，就是索引
![图1  一个例子](http://upload-images.jianshu.io/upload_images/4685968-c65be07333dbfb27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
图1展示了一种可能的索引方式
左边是数据表，两列14条记录，最左边是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上并不一定物理相邻）
为加快`Col2`的查找，可维护一个右边所示二叉查找树，每个节点分别包含索引键值及一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2 N)内取到相应数据

虽然这是一个货真价实的索引，但实际数据库系统几乎没有使用二叉查找树或其进化品种[红黑树](http://en.wikipedia.org/wiki/Red-black_tree)（red-black tree）实现
## 1.2 经典常用索引类型:B Tree和B+Tree
目前大部分数据库系统及文件系统都采用B Tree或其变种B+Tree作为索引结构
### 1.2.1 B Tree
定义数据记录为一个二元组[key, data]
- key为记录的键值，对于不同数据记录，key互不相同
- data为数据记录除key外的数据

B Tree有如下特点:
- d为大于1的一个正整数，称为B-Tree的度
- h为一个正整数，称为B-Tree的高度
- 每个非叶节点由n-1个key和n个指针组成，其中d<=n<=2d
- 每个叶节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null
- 所有叶节点具有相同的深度，等于树高h
- key和指针互相间隔，节点两端是指针
- 一个节点中的key从左到右非递减排列
- 所有节点组成树结构
- 每个指针要么为null，要么指向另外一个节点
- 如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于>v(key1),v(key1)为node的第一个key的值
- 如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym),v(keym)为node的最后一个key的值。
- 如果某个指针在节点node的左右相邻key分别是keyi,keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)
![图2 d=2的B-Tree示意图](http://upload-images.jianshu.io/upload_images/4685968-34e495925cfc43c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
由于B Tree的特性,按key检索数据的算法非常直观
- 首先从根节点二分查找
- 如果找到则返回对应节点的data
- 否则对相应区间的指针指向的节点递归进行查找
- 直到找到目标节点/null指针，查找成功/失败
```java
bTreeSearch(node, key) {
    if(node == null) return null;
    foreach(node.key) {
        if(node.key[i] == key) return node.data[i];
            if(node.key[i] > key) return bTreeSearch(point[i]->node);
    }
    return bTreeSearch(point[i+1]->node);
}
data = bTreeSearch(root, my_key);
```
关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为![](http://upload-images.jianshu.io/upload_images/4685968-34aa3d92c8cdc09c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
检索一个key，其查找节点个数的渐进时间复杂度为![](http://upload-images.jianshu.io/upload_images/4685968-701af563134cfe20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
从这点可以看出，B Tree是一个非常有效率的索引数据结构
### 1.2.2 B+Tree
B-Tree有许多变种，其中最常见的是B+Tree，MySQL普遍用其实现索引
与B Tree相比，B+Tree有以下不同点
- 每个节点的指针上限为2d
- 内节点只存key
- 叶节点不存指针,叶节点指向被索引的数据而不是其他叶节点
    - innodb中,指向的是主键
    - myshaym中指向的是数据的物理地址
![图3 一个简单的B+Tree](http://upload-images.jianshu.io/upload_images/4685968-05ffda612519b2a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同
这点与B Tree不同，虽然B Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B Tree往往对每个节点申请同等大小的空间

一般来说，B+Tree比B Tree更适合实现外存储索引结构
####1.2.2.1  带有顺序访问指针的B+Tree
在经典B+Tree的基础上进行了优化，增加了顺序访问指针
![图4](http://upload-images.jianshu.io/upload_images/4685968-dfd900ea7ac5deee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如图4所示，在B+Tree的每个叶节点增加一个指向相邻叶节点指针，形成带有顺序访问指针的B+Tree
此优化的目的是提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了区间查询效率
##1.3 为什么使用B Tree（B+Tree）
红黑树也可用来实现索引，但是文件系统及数据库系统普遍采用B/+Tree,何也?

一般来说，索引本身也很大，不可能全存内存，往往以索引文件的形式存在磁盘

索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。

B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题,正是为了解决这个问题,B+树应用而生.B+树只需要去遍历叶子节点就可以实现整棵树的遍历.而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）.　　

换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数
##1.4 主存存取原理
计算机使用的主存基本都是随机读写存储器（RAM），抽象出一个十分简单的存取模型来说明RAM的工作原理
![图5  4x4的主存模型
](http://upload-images.jianshu.io/upload_images/4685968-c01748789e4b937d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据
每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元
- 存取过程
当系统需要读取主存时，将地址信号通过地址总线传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线，供其它部件读取

- 写主存
过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作

这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的
## 1.5  磁盘存取原理
索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O
与主存不同，磁盘I/O存在机械消耗，因此磁盘I/O时间消耗巨大
![图6 磁盘的整体结构示意图](http://upload-images.jianshu.io/upload_images/4685968-7f653ab7b3304e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各磁盘必须同步转动）
在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）
![图7 磁盘结构的示意图](http://upload-images.jianshu.io/upload_images/4685968-33af042b686050a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。

当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区
为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间
## 1.6  局部性原理与磁盘预读
由于存储介质特性，磁盘本身存取就比主存慢，再加上机械运动耗费，磁盘的存取速度往往是主存的几百万分之一，因此为了提高效率，要尽量减少磁盘I/O。
为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：
`当一个数据被用到时，其附近的数据也通常会马上被使用`
`程序运行期间所需要的数据通常比较集中`
由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率

`预读的长度一般为页（page）的整数倍`
页是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页大小通常为4k），主存和磁盘以页为单位交换数据
当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行
## 1.7  B/+Tree索引的性能分析
一般使用磁盘I/O次数评价索引结构的优劣

### B Tree分析
检索一次最多需要访问h个节点
数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入
为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：
-  每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O
- B-Tree中一次检索最多需要h-1次I/O（根节点是常驻内存的），渐进复杂度为O(h)=O(logdN)。
一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）

综上所述，用B-Tree作为索引结构效率是非常高的

### 红黑树
h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多

B+Tree更适合外存索引，原因和内节点出度d有关
从上面分析可以看到，`d越大索引的性能越好`
`出度的上限取决于节点内key和data的大小`：
```
dmax=floor(pagesize/(keysize+datasize+pointsize))
```
floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，更好的性能
# 2. MySQL索引实现
索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式
##2.1 MyISAM索引实现
使用B+Tree作为索引结构，叶节点data域存放数据记录的地址
![图8 MyISAM索引的原理图](http://upload-images.jianshu.io/upload_images/4685968-3c528e050ba99593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
设Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示例
可以看出MyISAM的索引文件仅仅保存数据记录的地址

在MyISAM中，主/辅索引在结构上没有任何区别，只是主索引要求`key唯一`，而辅索引`key可重复`

如果我们在Col2上建立一个辅索引
![图9 Col2上建立的辅索引](http://upload-images.jianshu.io/upload_images/4685968-ca234341ecc259d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
同样也是一颗B+Tree，data域保存数据记录的地址。
因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分
##2.2 InnoDB索引实现
虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同

第一个重大区别是
- `InnoDB的数据文件本身就是索引文件`
  - MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址
  - 而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引
![图10 InnoDB主索引（同时也是数据文件）示意图](http://upload-images.jianshu.io/upload_images/4685968-36a10ea5ce6fdea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
可以看到叶节点包含了完整的数据记录。这种索引叫做`聚集索引`
因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形

第二个与MyISAM索引的不同是
- InnoDB的辅索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域
![图11 定义在Col3上的一个辅索引](http://upload-images.jianshu.io/upload_images/4685968-9e8eb904029b3bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
这里以英文字符的ASCII码作为比较准则
聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：
  -   首先检索辅助索引获得主键
  - 然后用主键到主索引中检索获得记录

知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅索引都引用主索引，过长的主索引会令辅索引变得过大
再如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择

## 聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种`数据存储方式`。

具体的细节依赖其实现方式，但InnoDB 的聚簇索引在同一结构中`保存了B-Tree索引和数据行`，是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。
- 特点
存储数据的顺序和索引顺序一致。

一般情况下主键会默认创建聚簇索引，且`一张表只允许存在一个聚簇索引`。

当表有聚簇索引时，它的数据实际上存放在索引的叶子页（leaf page），`‘聚簇’`表示数据行和相邻的键值进错的存储在一起。`因为无法同时把数据行存放在两个不同地方，所以在一个表中只能有一个聚簇索引` （不过，覆盖索引可以模拟多个聚簇索引的情况）。

InnoDb将通过主键聚集数据。

如果没有定义主键，InnoDB 会选择一个唯一的非空索引代替
如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引
InnoDB值聚集在同一个页面中的记录,包含相邻键值的页面可能会相距很远

## InnoDB 和 MyISAM的数据分布对比
聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别
来看看InnoDB和MyISAM是如何存储下面的这个表的
```
CREATE TABLE layout_test(

　　　　col1 int not null,

　　　　col2 int not null,

 　　　  primary key (col1),

　　　　key(col2)

　　);
```
假设该表的主键取值为1-1w，按照随机顺序插入，并使用`OPTIMIZE TABLE`命令优化
换句话说，数据在磁盘的存储方式已经最优，但进行的顺序是随机的
列col2的值时从1-100之间随机赋值，所以有很多重复的值

### MyISAM 的数据分布
MyIsam按照数据插入的顺序存储在磁盘上

实际上，MyISAM 中主键索引和其他索引在结构上没有什么不同
主键索引就是一个名为PRIMARY的唯一非空索引

### InnoDB 的数据分布
因为InnoDB支持聚簇索引，索引使用非常不同的方式存储同样的数据。在InnoDB中，聚簇索引“是”表，所以不像myISAM那样需要独立的行存储

### 聚簇索引的一些重要优点：
- 可以把相关的数据保存在一起
例如，实现电子邮箱时，可以根据用户id来聚集数据这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次I/O
- 数据访问更快
聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比非聚簇索引中快
- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

 

　　聚簇索引的缺点：

　　聚簇索引最大限度的提高了io密集型应用的性能，但如果数据全部存放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没有什么优势了。

　　插入速度严重依赖插入顺序。按照主键的顺序插入是加载数据到innodb表中速度最快的方式。但如果不是按照主键顺序加载数据，那么加载完成后最好使用OPTIMIZE TABLE 命令来重新组织一下表。

　　更新聚簇索引的代价很高，因为会强制InooDB将每个更新的数据移动到新的位置。

　　基于聚簇索引的表在插入行，或者主键被更新导致需要移动行的时候，可能面临’页分裂（page split）‘的问题。当行的主键值要求必须将这一行插入到某个已满的页中时。存储引擎，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的存储空间。

　　聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。

　　二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的子节点包含了最优一个几点可能让人有些疑惑，为什么二级索引需要两次索引查找？答案在于二级索引中保存的“行指针”的实质。要记住，二级索引叶子节点保存的不是只想物理位置的指针，而是行的主键值。

　　这意味着通过二级索引进行查找行，存储引擎需要找到二级索引的子节点获得对应的主键值，然后根据这个值去聚簇索引总超找到对应的行。这里做了重复的工作：两次B-Tree查找，而不是一次。对于InnoDB，自适应哈希索引能够减少这样重复工作。

在《数据库原理》一书中是这么解释聚簇索引和非聚簇索引的区别的：
- 聚簇索引的叶子节点就是数据节点
- 非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

因此，MYSQL中不同的数据存储引擎对聚簇索引的支持不同就很好解释了。
下面，我们可以看一下MYISAM和INNODB两种引擎的索引结构。

如原始数据为：
![](https://upload-images.jianshu.io/upload_images/4685968-ece2b523748fda67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
MyISAM引擎的数据存储方式,如图
![](https://upload-images.jianshu.io/upload_images/4685968-6ad71a2daeace2bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
MYISAM是按列值与行号来组织索引的
它的叶子节点中保存的实际上是指向存放数据的物理块的指针。
MYISAM引擎的索引文件（.MYI）和数据文件(.MYD)是相互独立的。

而InnoDB按聚簇索引的形式存储数据，所以它的数据布局有着很大的不同。它存储数据的结构大致如下：
![](https://upload-images.jianshu.io/upload_images/4685968-15f63d367a077aa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


注：聚簇索引中的每个叶子节点包含主键值、事务ID、回滚指针(rollback pointer用于事务和MVCC）和余下的列(如col2)。

INNODB的二级索引与主键索引有很大的不同。InnoDB的二级索引的叶子包含主键值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新索引的行指针。其结构大致如下：
![](https://upload-images.jianshu.io/upload_images/4685968-1d56a6bc5696d4cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


INNODB和MYISAM的主键索引与二级索引的对比：
![](https://upload-images.jianshu.io/upload_images/4685968-d234ca8591982647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

InnoDB的的二级索引的叶子节点存放的是KEY字段加主键值。因此，通过二级索引查询首先查到是主键值，然后InnoDB再根据查到的主键值通过主键索引找到相应的数据块。而MyISAM的二级索引叶子节点存放的还是列值与行号的组合，叶子节点中保存的是数据的物理地址。所以可以看出MYISAM的主键索引和二级索引没有任何区别，主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键。